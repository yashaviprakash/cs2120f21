import data.set

/- 
PART II: BASIC SET THEORY

Give formal and English language proofs of 
the following conjectures.

to show that two sets are equal show that one is the 
subset of the other and vice versa
-/

/-
We'll use our favorite set, of the even
numbers, in what follows, so we define it
again here. 
-/
def evens : set ℕ := { n | n%2 = 0}

/-
PROOFS INVOLVING SUBSET RELATIONS
-/

example : ({ 0, 2 } : set ℕ) ⊆ evens :=
/-
Before looking at the proof script, spend
a good bit of time trying to be sure that
you see how the proof will work. We want
to prove a subset relation, so we want to
prove that for all values, v, if v is in
the first set, then v is in the second. 
The rest of the proof is by case analysis.
v ∈ {0, 2} means v = 0 ∨ v = 2. These are
the cases. In each case, we need to show
that the value, v, is in the second set. 
This means that the value satisfies the 
set membership predicate, so we will need
to prove (evens 0) and (evens 2). Writing
out the definition of evens, we'll need to
prove 0 % 2 = 0 and 2 % 2 = 0, and these
are true by the reflexivity of equality.

Here we hope you see how vitally important 
it is to *learn* the basic definitions and
to *look them up* again if you forget them 
or get stuck. Always go to the definitions
if you get stuck. That's how to learn or to
*remember* what the symbols and other terms
mean. Putting  the smaller pieces together
again will often reveal how to get unstuck. 

This principle is particularly important
right now because we've introduced a major
new layer of abstractions, from logic to 
set theory, with its associated definitions
and notations (see lecture_18). You need 
to memorize these definitions and notations
to be able to deal with propositions and 
proofs in set theory.
-/

/-
So here's a proof script in Lean. Follow it
step by step, carefully studying your "proof
state" (context and goal) after each "move."
Be sure you can relate the informal proof
above to the formal proof generated by this
script.
-/

begin
  show ∀ n, n = 0 ∨ n = 2 → n ∈ evens,
  -- \assume n,
  -- assume h, -- assume these numbers are in the first set, n is in this set when n is 0 or n is 2
  -- cases h, -- two cases: 1) when n = 0 or the case when 2) n is in the rest of the set {2}
  -- -- case: n = 0
  -- rw h,
  -- --unfold evens,
  -- --show {n : ℕ | n % 2 = 0} 0,
  -- --show 0 % 2 = 0,
  -- exact rfl, -- proof by reflexivity because you're trying to show that evens applied to 0 is true
  -- -- case: n = 2
  -- cases h, -- have to show that evens applied to 2 is true
  -- --show 2 ∈ evens, what you're really trying to show is that 2 is in events
  -- --show evens 2, basically the membership predicate
  -- --unfold evens, membership predicate applied to 2 will give you:
  -- --show 2 % 2 = 0, now you can use reflexivity
  -- exact rfl,
  /-
  Uncomment next line to see how to use show
  to rewrite a goal to "definitionally equal" 
  form. The rewriting here makes it easier to
  see exactly when the first two moves are to
  assume that you're given argument values, n
  and h. This rewriting is not needed though 
  for the rest of the proof to work as is.
  -/
  -- show ∀ n, n = 0 ∨ n = 2 → n ∈ evens,
  assume n,
  assume h,
  cases h,

  -- case: n = 0
  rw h,   -- by substitutability of equals
  /-
  Uncomment the following lines if you want
  to see in more detail why it makes sense 
  that rfl is what's needed to finish the
  proof. (But before you do, try to work it
  out in your own head!)
  -/
  unfold evens,
  show {n : ℕ | n % 2 = 0} 0, --membership means that value satisfies predicate of evenness
  show 0 % 2 = 0,
  show 0 = 0,
  exact rfl,

  -- case: n = 2
  cases h,
  /-
  A comment is required here. Sometimes a proof
  assistant will use an unusual term for what
  you'd write more simply. Here (1.add 0).succ
  means the successor of 1 + 0, i.e., 2. You 
  don't need to even ask why. Just know that
  you're really just looking at "2" here.

  At this point you have h, a proof, h, of 
  2 = 2 (albeit written in a strange way), and
  you need to prove that 2 (writen weirdly)
  is in the evens set. In this case, the h is
  not needed, as the proof that "2 is even" is
  by the reflexivity of equality.
  -/

  --uncomment for unnecessary gory details!
  
  show 2 ∈ evens,
  unfold evens,
  show evens 2,
  show 2 % 2 = 0,
  show 0 = 0,
  
  exact rfl,    -- Ta Da!
end

/-
THE MEANING OF AND PROOF INVOLVING SET EQUALITY
-/

/-
We now look at the concept of *equality* 
of sets. To show that two sets are equal,
e.g., L = X, we need to show that a value
is in L if and only if it's in X. This is
the same as showing L ⊆ X ∧ X ⊆ L. That 
is a take-away message: To prove two sets 
equal, you can prove that each is a subset 
of the other.
  
Now *please* expand definitions to see that
L ⊆ X ∧ X ⊆ L means 
  ∀ x, 
    (x ∈ L → x ∈ X) ∧
    (x ∈ X → x ∈ L)
which we can also write as
  ∀ x, x ∈ L ↔ x ∈ X.

/-
Remember that you can think about an
implication, P → Q, in two ways: first,
if P then Q; second, to prove Q it will
suffice to prove P. So to prove L = X, **To prove Q it will suffice to prove P**
it suffices to prove ∀ x, x ∈ L ↔ x ∈ X,
because one can then apply ext to that
proof to derive a proof of L = X. In 
other words, ext lets you "reduce" the
need for a proof of L = X to the need
for a proof of ∀ x, x ∈ L ↔ x ∈ X. And
that is what we see next. 

The concept of set equality, and the 
need to prove certain sets to be equal,
is extremely common, so it's important
to master these concepts here.
-/
Now to get from a proof of that to a 
proof of L = X requires a new axiom, called
set extensionality. It just says that if 
we prove ∀ x, x ∈ L ↔ x ∈ X then we can, 
by applying the axiom, deduce that L = X.
-/ 

#check @set.ext 

/-
The set extensionality axiom in Lean is
called ext, defined in the set namespace; 
so you can refer to it either as set.ext, 
or you can open the set namepace and then
just call it ext. 
-/

/-
NOTE ON APPLYING P → Q TO REDUCE Q TO P. 
-/

/-
Remember that you can think about a
proof of an implication, P → Q, in two 
ways: first (reading left to right), it
shows that if P (is true) then (so is) Q; 
second (reading right to left), it says
that if you need to show Q it suffices 
to show P because P → Q will then give 
you the Q you need. 

Reading #2 is what we exploit here. The 
salient point is that if you know P → Q
and you need to show Q, then it suffices 
to show P. P → Q thus allows you to reduce
the problem of showing Q to the problem of
showing P! This is a really important idea
to have in your mind.  It's the principle 
that we use in this next concrete example.
-/

/-
Here's how we use that basic idea.
To prove L = X, it will suffice to prove 
∀ x, x ∈ L ↔ x ∈ X. If one has a proof
of ∀ x, x ∈ L ↔ x ∈ X, then one easily
obtains a proof of L = X by applying the
axiom of extensionality to it. Reading
right to left, if we need to prove L = X, 
it will suffice to prove ∀ x, x ∈ L ↔ x ∈ X 
(as one then just applies ext to get the
desired proof of X = L). 

Look again at the definition of ext.

  set.ext : 
    ∀ {α : Type u_1} {a b : set α}, 
    (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b

What is says is that we can apply ext
to a proof of ∀ x, x ∈ L ↔ x ∈ X to get
a proof of L = X. 

Here's the most important point: If we 
apply ext to a "hole" where the proof 
of the bi-implication should be, we will 
have our proof of L = X, with only the
proof of ∀ x, x ∈ L ↔ x ∈ X remaining 
to be produced. In this sense, applying
the axiom of set extensionality without
giving a proof of the bi-implication,
*reduces* the problem of proving L = X
to the problem of proving ∀ x, x ∈ L ↔ 
x ∈ X. And that is what we see next. 
-/

-- if L is a subset of X then the intersection of L and X is L
example : ∀ {α : Type} (L X : set α), L ⊆ X → ((L ∩ X) = L) := 
begin
  intros α L X h,
  apply set.ext _,  -- reduce = to ↔ by set extensionality
  /- 
  That's the whole proof as long as we can fill in the _
  That's what the rest of this proof script then does. 
  Notice again how "applying an implication theorem" 
  can be used to reduce a current proof goal to goals 
  the satisfaction of which "will suffice" to enable
  construction of the proof that's needed.
  -/
  assume x,
  split,
  -- forward
  assume h,
  /- 
  Remember, h is a proof of a conjunction
  so "cases h" really does and elimination 
  giving us the left and right subproofs as
  the arguments that must have been given as
  arguments to the and.intro that must have
  been used to construct such a proof in 
  the first place.
  -/
  cases h with l r,
  exact l,
  -- quiz: would "exact h.left" have worked?
  -- predict the answer before checking

  -- backward
  assume k,
  have r := h k,
  apply and.intro k r,
  /-
  So this last "proof move" will take a little
  time to think about. Look at the goal and think
  for yourself what you really need to prove here.
  Go back to the definitions! x ∈ L ∩ X really 
  just means L x ∧ X x. Does this help you to see
  why and.intro is required here, and what each 
  of the terms in the preceding expression must
  means?
  -/
end 

